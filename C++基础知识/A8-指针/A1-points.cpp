1、我们可以通过一个“指针”来保存一个【地址】


2、开始【定义指针】
    //指针定义的语法：数据类型  *指针变量名；
    int a = 10
    int *p=&a; 打印p，显示是地址，不过指针指向a，需要&符号
    
    【下述两个的效果是一致的】---地址
    cout<<"a的地址为"<<&a<<endl;
    cout<<"points p = "<<p<<endl;

3、使用指针
  //指针的“解引用”
  在指针前加 *  便是解引用，找到指针指向的内存中的数据
  *p = 1000 
  
  【为什么这里*p表示的是解引用】---指向的是内存的值；---可以用*p修改值
  1、因为指针的定义是 数据类型 *指针名
  2、 * 在指针前，你可以理解为**p
  
  
  
4、指针数据类型占用多少字节呢？

    在32位的操作系统下，占用的是4个字节
    在64位的操作系统下，占用的是8个字节
    
    
    int a=10
    int *p = &a
    cout<<*p<<endl;
    cout<<sizeof(p)<<endl;查看的是指针
    cout<<sizeof(float *)<<endl;   在32位的操作系统下，占用的是4个字节
    cout<<sizeof(double *)<<endl;  cout<<sizeof(float *)<<endl;
    
    
5、空指针 ；指针变量纸箱内存中编号为0的空间【此时无法访问】

      1、用于给指针变量初始化
      2、不可以访问
      3、定义的指针方式：  int *p=NULL（0~255）编号的内存是系统访问的
      数据类型  *指针名=NULL
  
  
 6、野指针：在程序中，尽量避免这种情况
 
      空指针，野指针都不是我们定义的
      
      int *p = (int *)ox0011;
 
      
7、const指针：constant常量

      【常量指针】
      const int *p=&a; 如果这个指针是const指针，它的地址可以进行修改，但是它的值不能修改
      
      *p =20;  错误，不可能修改
      p = &b; 正确



    【指针常量】
    int const *p=&a;  你只能修改值，不能修改引用
    
    1、指针常量，说明指针是不能修改地址的，但是你的地址的值可以改变啊
    2、常量指针：const int *p，它的目的是让值是常量，并不希望值进行改变；
       *p =20;  正确，不可能修改
      p = &b; 错误


8、如何记住呢？
  
    在数据类型前放const ，是为了约束值，因此不希望改值  const（常量） int *p 常量+指针--常量指针
    在数据类型后放const，是为了约束指针，因此不希望改地址   int connst(常量) *p:常量指针
    const int const *p=&c： 指针的地址和值都不能修改c















      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    
    
    
    
    
    
    
    
    
    
  
  
