1、深拷贝和浅拷贝的区别是什么？
 深拷贝是将对象本身赋值给另一个对象，是一种“值拷贝” ， 如果对“对象”的副本进行更改，原对象不会改变。
 copy.deepcopy()
    (1)两个变量的内存地址不同两个变量各有各自的值，且互不影响。
    (2)对其任意一个变量的值得改变不会影响另一个

 浅拷贝：
 1、将对象的引用赋值给另一个对象，是对内存地址的拷贝。（公用一个内存地址）

 区别：前者‘值拷贝’，但是内存空间占用大：
      后者‘地址拷贝’
      python是不明确区分，拷贝和引用，一般对静态变量的传递为拷贝（字符串，数值，元组），对动态变量的传递为引用（字典）

 你的回答：深拷贝是‘值拷贝’，修改副本的值，不会影响到原地址的值，而具有这类类型的数据结构有，数组、元组、字符串等
        浅拷贝是‘地址拷贝’，修改其中一个指向该地址的变量的值，会同时影响其它指向该地址的变量，---字典
-------------------------------------------------------------------------------------

2、解释一下‘args’和’kwargs‘
如果我们无法确定将多少【参数传递】给函数，则我们可以使用*args将输入的参数【打包】成（元组）tuple给函数体，此外当我们不知道需要传递
多少【关键字】参数时候，我们可以使用*kwargs将关键字参数打包成’dict’给函数体。

关键字参数：i=1,i就叫做关键字参数 ；

你的回答：你无法确定你需要传入多少‘参数时候’，你可以选择使用*args将它打包成元组，反之，如果是需要传入多个‘关键字参数’那么使用*kwargs
        将其打包成字典。
===尝试一下
-------------------------------------------------------------------------------------

3、python和其它语言的区别

你的回答：python代码，简洁明确，简单易懂开发效率高，可拓展性强
-------------------------------------------------------------------------------------

4、简述‘解释型’和‘编译型’编程语言

解释型：在执行程序时候，计算机才一条一条的将程序编译成【机器语言】给计算机来执行
编译型；把源程序的每一条语句编译成机器语言，并保存成二进制文件，这样计算机运行该程序时候直接以机器语言来运行此程序，速度更快。

你的回答：
    python是解释性语言，它在程序执行的时候，计算机一条条的将其编译成机器语言之后才开始执行，而java是一种
    编译型语言，它在执行程序的时候，会先将程序编译成二进制文件，之后在执行的时候直接执行编译好的文件。相较于python
    java的运行效率更快。

-------------------------------------------------------------------------------------
5、python解释器种类以及特点

python是一门解释性的语言，代码像运行必须通过解释器执行，python存在多种解释器，分别基于不同语言开发，每个解释器有
不同的特点。
CPython是使用c语言开发的，是使用最广的解释器
Ipython是一种基于cpython之上的一个交互式解释器，知识在交互方式上有所增强，执行python代码的功能和cpython是一样的
pypy，是另一个python解释器，它的目标是执行速度，采用JIT技术，对python进行动态编译，具有显著的速度

-------------------------------------------------------------------------------------

6、位和字节的关系
1位=8字节
-------------------------------------------------------------------------------------

7、ASCII \UNICODE\UTF-8 \GBK
ascii：是一个【字节编码】，范围基本只有英文字母、数字和一些特殊符号，只有256个字符：
unicode：能够表示全世界所有的字节
GBK：只能用来编码汉字
utf-8：一种针对unicode的可变长度字符编码，又称【万国码】
-------------------------------------------------------------------------------------

8、python2 和 python3的区别
-------------------------------------------------------------------------------------

9、文件操作时，xreadlines 和readlines的区别
with open('file_addr','a') a,r,a+
readlines返回一个list，而xreadlines返回一个【生成器】

你的回答：短的返回list，长的返回生成器【genetator】
-------------------------------------------------------------------------------------
10、字符串 列表 元组、字典每个常用的五个方法

字符串： replace(old,new,[,max]) max指的是替换次数
        strip（）删除两侧的空字符 lstrip（） rstrip（）
        split（）切割
        upper（）全部变大写
        lower（）全部变成小写
        join （）拼接
        find（str,beg=0,end=len(string)），检查str是否在 beg~end这个范围之内，找子串,存在返回地址，不存在返回-1
        index地址索引
列表：
    append（）加
    pop（）丢
    insert（）插入
    remove（）移除
    sort(reverse=True)排序，会修改值
    sorted()知识软排序
    reverse()翻转
    index（） 给地址返回值
元组：【不能修改】
    index
    count
    len()
    dir():创建字典
    max
    min
字典：key value
    items 以列表返回可遍历的（键，值）元祖数组
    get 返回指定键的值，如果值不再字典中返回default
    values 返回一个迭代器，可以使用list()来转换为列表
    pop  删除字典给定键key所对应的值，返回值为被删除的值。
    popitems    [随机返回]并删除字典中的一对键和值
    clear  删除字典内所有元素
    update(dict2) 把dict2的键值对更新到dict里
    keys 返回一个迭代器，可以使用list()来转换为列表
dict={'Name':'Runoob','Age':7,'Class':,'First'} dict['Age']=8 dict['School']="菜鸟教程"
-------------------------------------------------------------------------------------
11.lambda 表达式以及应用场景：
lambda函数赋值给其他函数
lambda后面跟一个或多个参数，紧跟一个冒号，以后是一个表达式。冒号前是参数，冒号后是返回值

你的回答：【lambda x:2x】

-------------------------------------------------------------------------------------
12、pandas 中map   applymap 和 apple的区别
apple（）是一种让函数作用于列或者行（一维向量）操作。
applymap()是一种让函数作用于DataFrame每一个元素的操作（选取的是所有数据即Dataframe) map是一种让函数作用于series每一个元素的操作
-------------------------------------------------------------------------------------
13 pass作用

你的回答：让程序的语义完整
        def func1（*kargs）：
            pass

-------------------------------------------------------------------------------------

14 is 和 ==区别

回答：
  【is 判断是否【地址】相等
  == 判断是否【值】相等】

print(a is b)
pring(a==b)
-------------------------------------------------------------------------------------
15、python垃圾回收机制

采用计数机制为主，【标记-收集】---主 和 【分代收集】---辅

标记-清除：---【解决容器对象可能产生的循环引用的问题】
它只关注可能会产生循环引用的对象缺点：该机制所带来的额外操作和需要回收的内存块成正比

隔代回收：
将系统中的所有内存块根据其存活时间划分为不同的集合，【每一个集合就成为一个“代”，】垃圾收集的频率随着“代”的存活时间的增大而减小。
也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。

-------------------------------------------------------------------------------------
16、python的可变类型和不可变类型

不可变类型： 数字、字符串、元组
不可变集合【可变类型】：列表 字典 可变集合
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
18.filter map reduce的作用
filter(function,iterable) 过滤函数
map(function,iterable) 循环函数
reduce(function,iterable)累积函数

-------------------------------------------------------------------------------------
19、全局变量的关键字：
【global】
-------------------------------------------------------------------------------------
20、logging模块的作用，应用场景
【作用】：程序调试
【应用场景】：了解软件程序运行情况，是否正常软件程序运行故障分析和问题定位
-------------------------------------------------------------------------------------
21、常用字符串格式化哪几种
1、%s%
print("这位同学叫%s,年龄是%d岁" %('小明',10))
2、fomat格式化输出
    print（‘str{name},{age}’.format(name='xiaoming',age='18))
3、
print（f"str{value}")  value是需要传入的
-------------------------------------------------------------------------------------

22、【简述生成器、迭代器 可迭代对象 以及应用场景】

【生成器】在python中，一边循环一边计算的机制，称之为生成，并通过next（）取值。
【迭代器】：是访问集合元素的一种方式。迭代器同时实现了iter和next可迭代对象
【应用场景】应用场景：优化代码，节省内存。比如使用python读取一个10g的文件，如果一次性将10g的文件加载到内存处理的话（read方法)，
内存肯定会溢出；这里如果可以使用生成器把读写交叉处理进行，比如使用(readline和 readlines)就可以在循环读取的同时不断处理，
可以节省大量的内存空间。

2.含有yield关键字的函数
-------------------------------------------------------------------------------------
23、set 和 list的相互转换
s = set('12342212') #生成集合
l = ['12342212']
【集合转列表】：
s = set(l[0]) #集合中的第一个元素转换为集合

【列表转集合】：
l = list(s)


如果list为多个数值m = ['11','22','3']
print(set(m))

-------------------------------------------------------------------------------------
24、【面向对象深度优先和广度优先是什么，说明应用场景。】
1.	深度优先：经典类多继承搜索的顺序，先深入继承树左侧查找，然后再返回，开始查找右侧
2.	广度优先：新式类多继承搜索的顺序，先在水平方向查找，然后再向上查找 41.简述_init_和_len_这两个魔术方法的作用
构造方法_init_：当一个对象被创建后，会立即调用该构造方法，自动执行构造方法里面的内容构造方法_len_:该构造方法会返回元素的数量

-------------------------------------------------------------------------------------
25、python是如何进行内存管理的（如何实现垃圾回收机制）
【垃圾回收机制采用的是引用计数机制为主，标记-清楚和分代收集两种机制为辅的策略】
-------------------------------------------------------------------------------------
26、python中的模块和包是说明

【模块】 即工具包，单个python文件也可以是一个模块 ，若要引用它则需要导入
【包】 将有联系的【模块】组织在一起的一个集合，有效避免名称冲突问题
包是模块的集合，目的是避免同名冲突
-------------------------------------------------------------------------------------
27、python中的【装饰器】的作用和功能

装饰器本质上是一个函数，该函数用来处理其它函数，【它可以使得其它函数在不需要修改代码的前提下增加额外的功能】
【功能】
1、引入日志
2、函数执行的时间统计
3、执行函数前预备处理
4、执行函数后清理功能
5、权限校验等场景
6、缓存
-------------------------------------------------------------------------------------
28、继承

一个类继承自另一个类，同时获取所有的【类成员】---属性和方法
支持以下类型的继承：
单继承-一个子类类继承自【单个基类】多重继承-一个子类继承自【多个基类】多级继承-一个子类继承自一个基类，
而基类继承自另一个基类分层继承-多个子类继承自同一个基类混合继承-两种或两种以上类型继承的组合
-------------------------------------------------------------------------------------
29、python中的【三元表达式】：
[expression1 on true] if [expression] else [expression2 on false]
三元表达式指的是，如果expression是True 则执行 expression1 否则执行expression2
-------------------------------------------------------------------------------------
30、【yeild和 yeild from关键字】
yield是一个类似return的关键字，只是这个函数返回的是个生成器，当你调用这个函数的时候，函数内部的代码并不立马执行，这个函数只是返回一个生成器对象，当你使用for进行迭代的时候，函数中的代码才会执行。
yield关键字的工作机制：如果函数里面有yield关键字，这个函数的返回值是生成器。如果遇到yield，函数停止执行，当再次调用next方法时，从停止的地方继续执行。默认next方法会把yield后面的值返回回来。
yield from的主要功能是打开双向通道，把 外层的调用方与 内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量异常处理的样板代码。
有了这个结构，协程可以通过以前不可能的方式委托职责。


-------------------------------------------------------------------------------------
31、异常处理的写法：
try：
    xxx
except  Exception as a：
    print(a)

引用场景：
raise TypeError（‘出现了不可思议的异常’） #TypeError可以是任意的错误类型

-------------------------------------------------------------------------------------
32、列举面向对象中的也是成员以及应用场景
call:对象的构造方法，对象加上()，可以触发这个类的_call_方法 len:内置函数的len函数是依赖类中的_len_方法
 eq:判断值是否相等的时候依赖_eq_方法 hash:判断hash值是否相等的时候依赖_hash_方法
 （拓展：set的去重机制其实就是根据_hash_和_eq_方法实现的）
  str:和str() print() %s都是息息相关的，返回值一定是字符串类型
repr:和repr() %r都是息息相关的，在没有_str_方法时，repr_可以完全取代_str del析构方法，对应着一个对象的删除之前执行的内容

-------------------------------------------------------------------------------------
33、ininstance的作用以及应用场景

判断一个对象是否是一个已知的类型

-------------------------------------------------------------------------------------
34、静态方法
既不使用类中的属性又不使用对象中的属性，由类或者对象调用的方法，依赖 python装饰器@staticmethod来实现

类方法：
只使用类中的静态变量，一般都是由类调用，依赖python装饰器@classmethod来实现
-------------------------------------------------------------------------------------
35.【列举带双下划綫的特殊方法】：如new init
new:构造方法，创建一个对象，实例化时第一个被执行，返回一个创建好的对象及_init_(self)的self，
只有继承了object的类才会有这个方法 init:初始化方法，_init_在_new_的基础上完成一些其他初始化的动作，_init_没有返回值

-------------------------------------------------------------------------------------

36、os和sys模块的作用

os模块负责程序于操作系统的交互，提供了【访问】操作系统【底层接口】
sys模块则是负责程序与【python解释器】的交互，提供了一系列的函数和变量，用于操控python的运行是环境
-------------------------------------------------------------------------------------
37、如何使用python删除一个文件
import os
os。remove(r'path')
-------------------------------------------------------------------------------------
38、【面向对象的理解】
面向对象的程序设计的核心是对象，对象是特征和技能的结合，其中特征和技能分别对应对象的数据属性和方法属性。
面向对象编程可以将数据与函数绑定到一起，进行封装，这样能快速的开发程序，减少了重复代码的重写过程。优点是：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个任务参数的特征和技能修改都很容易
缺点：可控性差，无法像面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果
应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方

-------------------------------------------------------------------------------------

39、python面向对象中的继承有什么特点
在继承中基类的构造（init()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用
python同时支持单继承与多继承，当只有一个父类时为单继承，存在多个父类时为多继承。并且子类会继承父类的所有的属性和方法，子类也可以覆盖父类同名的变量和方法。
 	在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别于在类中调用普通函数时并不需要带上self参数
 	python总是首先查找对应类型的方法，如果它不能再派生类中找到对应的方法，它才开始到基类中逐个查找（先在本类中查找调用的方法，找不到才去基类中找）

-------------------------------------------------------------------------------------
27.面向对象中super的作用
  super在面向对象继承类中代指父类，可以快速调用父类，书写方法super(子类名，self).属性或者方法或super().属性或者方法
super方法可以增加类之间调用的灵活性，当父类名发生变化时不必修改 super方法在类的多继承时可以简化代码，避免代码冗余
super机制里可以保证公共父类仅被执行一次，执行的顺序遵循MRO，广度优先查询方法
28.是否使用过functools中的函数，作用是什么？
functools用于高阶函数，指那些作用于函数或者返回其他函数的函数。通常情况下，只要是可以被当做函数调用的对象就是这个模块的目标
29.列举带双下划綫的特殊方法：如new init
new:构造方法，创建一个对象，实例化时第一个被执行，返回一个创建好的对象及_init_(self)的self，只有继承了object的类才会有这个方法 init:初始化方法，_init_在_new_的基础上完成一些其他初始化的动作，_init_没有返回值

-------------------------------------------------------------------------------------



