题目要求：
![图片](https://user-images.githubusercontent.com/38878365/180638843-1c4e30e0-9628-4666-a4ec-7fdd0d041eaa.png)

在节点 c1 开始相交。

注意：

    如果两个链表没有交点，返回 null。
    在返回结果后，两个链表仍须保持原有的结构。
    可假定整个链表结构中没有循环。
    程序尽量满足 O(m+n) 时间复杂度，且仅用 O(1) 内存。


单链表：
1、不可能出现一个节点有两个输出地址，但是可能出现有两个节点指向同一个地址
2、如果两个链表相交，那么相交后的点是相同的，那么需要做的事情就是让两个链表从同距离末尾同等距离位置开始遍历，

解题思路：

【1】 初始化，pa指向headA ，同时pb指向HeadB，依次往后遍历，

【2】 边界判断 如果pa 或者pb是None，说明没有交点---直接返回None

【3】循环判断 pa！=pb，则一直循环：
     如果链表A比链表B先遍历结束，那么把链表a的指针pa设定为HeadB，继续遍历 ，反之pb设定为headA继续遍历；---
     这样做的好处是，当两次变换后，如果有交点，那么循环结束，输出任意一个pa或者pb即可；
     否则，如果没有交点，那么pa和pb都将指向None，那么输出任意一个都可；
     
【4】通过两次改变链表指针，时间复杂度为O（m+n）  

![图片](https://user-images.githubusercontent.com/38878365/180640016-f20008b2-2910-49d3-8b2c-6a44569c7037.png)

pb到了B的尾部，指向链表A的头部，此时A和B的长度差为B链表的长度，也就是3； ---如果是有交点，长度差的下一个节点就是相交点；

pa和pb都在遍历，哪一个先到尾巴，则将它的指针改为另一个指针的头部；接着遍历直到长的那个遍历完毕；那么如果有节点，就是后一个指针的下一个节点；

![图片](https://user-images.githubusercontent.com/38878365/180640024-fe267e31-f5d1-4f75-a426-d8083d9e2abb.png)

【pA到了末尾，，并移动到B的头部；此时PA和Pb到达末尾的长度一样，会同时到达尾部；】===

换句话说，你到达尾部的时间是一致的，那么你的下一个节点应该是一样的，如果不是，那么没有相交；

![图片](https://user-images.githubusercontent.com/38878365/180640274-cd67269d-0d4c-451f-897a-835072a2ed53.png)


![图片](https://user-images.githubusercontent.com/38878365/180716509-86bfadfa-13db-4a72-80eb-a39f93044884.png)


