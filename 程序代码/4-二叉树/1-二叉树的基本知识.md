    二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。
    
![图片](https://user-images.githubusercontent.com/38878365/184310716-8b2ff209-9983-4c5f-8e88-46df4c3f94a9.png)

    #define MAX_TREE_SIZE 100 /* 二叉树的最大节点数 */
    typedef TELemType SqBiTree[MAX_TREE_SIZE] /* 0号单元存储根节点 */
    typedef struct
    {
      int level, order; /* 即节点的层(按满二叉树计算) */
    }position;

![图片](https://user-images.githubusercontent.com/38878365/184310902-86d3f4b1-7a09-40ae-8cbf-2839fb0e0266.png)

        ########################################################################################
        1、深度优先遍历： 先序、中序、后序
        2、广度优先遍历： 层次
        
        深度
        递归方式 ：
        非递归：使用栈  ---重点关注 后序遍历，可以先遍历右子树，到头后再遍历左子树 ---最后输出 【逆序】
        ########################################################################################
        
        广度：
        1、
        if not root:
            return
        res = []
        stack = []
        while len(stack)!=0:
            temp=[]
            for i in range(len(stack):
                b =stack.pop(0)
                temp.append(b.val)
            if b.left:
                stack.append(b.left)
            if b.right:
                stack.append(b.righty)
            res.append(temp)
        return res
          
     
     
     
     ########################################################################################
     二叉排序树（也叫【二叉搜索树】）左--根---右 ）【从小到大】
     ########################################################################################
    若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
    若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
    它的左右子树也分别为二叉搜索树

    【注意：二叉搜索树中序遍历的结果是有序的】
     
     
     
    ########################################################################################
    【平衡二叉树】
    树中任意一个子树的【高度】差不超过1
    1、可以使用递归遍历每一棵子树之间的高度差；
    ########################################################################################
     
     
     
     
     
               
