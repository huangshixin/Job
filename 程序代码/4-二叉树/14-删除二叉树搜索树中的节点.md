




class Solution:
          def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
              cur, curParent = root, None #设置两个初始的节点，一个存放父节点，一个用于记录当前节点
              while cur and cur.val != key: #如果当前节点存在，且不等于所查找的key；【那么需要继续遍历】
                  curParent = cur  #将cur传给curParent ，目的是让cur不断的查询，而curPaarent保持cur父节点
                  cur = cur.left if cur.val > key else cur.right #开始判断与key的关系，如果大于它则去左子树寻找，否则右子树 ----说明要么已经找到，要么到头了
              if cur is None: #开始边界判断，如果为None；则直接返回root
                  return root
              if cur.left is None and cur.right is None: #左右子树都为空---叶子节点，因此返回None
                  cur = None
              elif cur.right is None: #因为上述已经判断是否是叶子，所以这个地方只需要判断是否右子树为空，空的话返回cur = cur.left
                  cur = cur.left
              elif cur.left is None: #同理
                  cur = cur.right
              else:#左右子树都存在;
                  successor, successorParent = cur.right, cur
                  while successor.left:#要找最左边的的那个子树
                      successorParent = successor
                      successor = successor.left
                  if successorParent.val == cur.val:#如果找到匹配值，那么把右子树给它
                      successorParent.right = successor.right
                  else:
                      successorParent.left = successor.right
                  successor.right = cur.right
                  successor.left = cur.left
                  cur = successor
              if curParent is None:
                  return cur
              if curParent.left and curParent.left.val == key:
                  curParent.left = cur
              else:
                  curParent.right = cur
              return root
