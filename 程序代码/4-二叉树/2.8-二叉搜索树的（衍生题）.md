1、验证一下，这棵树是不是二叉搜索树：
      
      【思路】
      1、要么按照规则判断，左子树<根 and  根<右子树；
      
      2、中序遍历--二叉搜索树---得到的是【有序】的数组；
          我选择第二个思路：
              中序遍历，并且在存入数组的时候，判断是否大于前一个值；如果遇到【等于】---也返回false
     class Solution:
      def isValidBST(self, root: Optional[TreeNode]) -> bool:

          #迭代法--中序
          '''
          中序遍历---有序数组---当前值【大于等于前一个】
          '''
          if not root:return False
          res = []
          stack = []
          while root or stack:
              while root:
                  stack.append(root)
                  root = root.left
              b = stack.pop()#没有左子树了，栈内出一个
              if res:
                  if res[-1]>=b.val:
                      return False
              res.append(b.val)           
              root = b.right
          return True
 


2、二叉搜索树中找到【众数】：---------这里的二叉搜索树包含【重复】节点

          解释说明：众数：如果树中所有节点只出现一次，那么直接打印全部节点，否则打印【最多的那个】
          
          
          
          
3、https://leetcode.cn/problems/minimum-absolute-difference-in-bst/          
