![图片](https://user-images.githubusercontent.com/38878365/188391854-a6d551ba-aeef-4772-8f42-db50d4c47338.png)
        #####################################################################################################
        102.二叉树的层序遍历
        #####################################################################################################
        
                1、判断边界
                2、设定两个栈分别存放节点以及存放【最终的每一层的列表】
                3、只有当root不为空的时候，每次往栈中存放节点；
                  for 循环表示本次栈中剩下多少个元素，从这些元素中进行遍历；
                  【即使后序有新的元素入栈，也不影响本次遍历】
                  将栈中拿出的节点的值存放到temp
                    每次从栈中拿到第一个节点，判断是否有左右子树，如果有则存放到【栈】的后端；
                   当for循环结束；将temp的值存放到输出的列表res；
                4、继续循环，直到栈中没有任何节点


        #####################################################################################################
        107.二叉树的层次遍历II
        #####################################################################################################
        199.二叉树的右视图
        
![图片](https://user-images.githubusercontent.com/38878365/188400585-b0ac791a-6caa-4f6f-9b99-0828315296fb.png)
        
        【解题思路】
                【
                先进行层次遍历：
                然后，相当于取层次遍历每一层的最后一个节点
                】
                
                # Definition for a binary tree node.
                # class TreeNode:
                #     def __init__(self, val=0, left=None, right=None):
                #         self.val = val
                #         self.left = left
                #         self.right = right
                class Solution:
                    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:

                        if not root:return []
                        res = []
                        stack = []
                        stack.append(root)
                        while len(stack)!=0:
                            temp = []
                            for i in range(len(stack)):
                                b = stack.pop(0)
                                temp.append(b.val)
                                if b.left:stack.append(b.left)
                                if b.right:stack.append(b.right)
                            res.append(temp)
                        a = []
                        for i in range(len(res)):
                            a.append(res[i][-1])

                        return a
        
        
        
        
        
        
        
        #####################################################################################################
        637.二叉树的层平均值
        【思路】
        1、计算层次遍历；
        2、在存入res的时候变成
        res.append(sum(temp)/len(temp))
        
        
        # Definition for a binary tree node.
        # class TreeNode:
        #     def __init__(self, val=0, left=None, right=None):
        #         self.val = val
        #         self.left = left
        #         self.right = right
        class Solution:
            def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
                if not root:return []
                res = []
                stack = []
                stack.append(root)
                while len(stack)!=0:
                    temp = []
                    for i in range(len(stack)):
                        b = stack.pop(0)
                        temp.append(b.val)
                        if b.left:stack.append(b.left)
                        if b.right:stack.append(b.right)
                    res.append(sum(temp)/len(temp))
                return res        
        
        
        
         
        
        ##################################################################################################### 
        429.N叉树的层序遍历
        ##################################################################################################### 
        515.在每个树行中找最大值
        【思路】
        1、还是使用层次遍历
        2、在存入res的时候使用res.append(max(temp))
        
        
        
        
        #####################################################################################################
        116.填充每个节点的下一个右侧节点指针
         #####################################################################################################
        117.填充每个节点的下一个右侧节点指针II
         #####################################################################################################
        104.二叉树的最大深度
         #####################################################################################################
        111.二叉树的最小深度    
