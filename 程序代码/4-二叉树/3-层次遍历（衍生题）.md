![图片](https://user-images.githubusercontent.com/38878365/188391854-a6d551ba-aeef-4772-8f42-db50d4c47338.png)
        #####################################################################################################
        102.二叉树的层序遍历
        #####################################################################################################
        
                1、判断边界
                2、设定两个栈分别存放节点以及存放【最终的每一层的列表】
                3、只有当root不为空的时候，每次往栈中存放节点；
                  for 循环表示本次栈中剩下多少个元素，从这些元素中进行遍历；
                  【即使后序有新的元素入栈，也不影响本次遍历】
                  将栈中拿出的节点的值存放到temp
                    每次从栈中拿到第一个节点，判断是否有左右子树，如果有则存放到【栈】的后端；
                   当for循环结束；将temp的值存放到输出的列表res；
                4、继续循环，直到栈中没有任何节点




        #####################################################################################################
        107.二叉树的层次遍历II
        #####################################################################################################
        
        
        
        
        
        
        #####################################################################################################
        199.二叉树的右视图
        #####################################################################################################
![图片](https://user-images.githubusercontent.com/38878365/188400585-b0ac791a-6caa-4f6f-9b99-0828315296fb.png)
        
        【解题思路】
                【
                先进行层次遍历：
                然后，相当于取层次遍历每一层的最后一个节点
                】
                
                # Definition for a binary tree node.
                # class TreeNode:
                #     def __init__(self, val=0, left=None, right=None):
                #         self.val = val
                #         self.left = left
                #         self.right = right
                class Solution:
                    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:

                        if not root:return []
                        res = []
                        stack = []
                        stack.append(root)
                        while len(stack)!=0:
                            temp = []
                            for i in range(len(stack)):
                                b = stack.pop(0)
                                temp.append(b.val)
                                if b.left:stack.append(b.left)
                                if b.right:stack.append(b.right)
                            res.append(temp)
                        a = []
                        for i in range(len(res)):
                            a.append(res[i][-1])

                        return a
        
        
        
        
        
        
        
        #####################################################################################################
        637.二叉树的层平均值
        #####################################################################################################
        【思路】
        1、计算层次遍历；
        2、在存入res的时候变成
        res.append(sum(temp)/len(temp))
        
        
        # Definition for a binary tree node.
        # class TreeNode:
        #     def __init__(self, val=0, left=None, right=None):
        #         self.val = val
        #         self.left = left
        #         self.right = right
        class Solution:
            def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
                if not root:return []
                res = []
                stack = []
                stack.append(root)
                while len(stack)!=0:
                    temp = []
                    for i in range(len(stack)):
                        b = stack.pop(0)
                        temp.append(b.val)
                        if b.left:stack.append(b.left)
                        if b.right:stack.append(b.right)
                    res.append(sum(temp)/len(temp))
                return res        
        
        
        
         
        
        ##################################################################################################### 
        429.N叉树的层序遍历
        ##################################################################################################### 
        515.在每个树行中找最大值
        【思路】
        1、还是使用层次遍历
        2、在存入res的时候使用res.append(max(temp))
        
        
        
        
        #####################################################################################################
        116.填充每个节点的下一个右侧节点指针
        #####################################################################################################
        
        
        
       #####################################################################################################
        117.填充每个节点的下一个右侧节点指针II
        #####################################################################################################
        
        
        
        #####################################################################################################
        104.二叉树的最大深度
        #####################################################################################################
        '''
        递归方法
        '''
        def get Max(root):
             if not root:return 0
             else:
                left  = max(root.left)
                right = max(root.right)
                return max(left,right)+1 
                #如果不为空的时候，我们去判断是否可以它的左右子树，
                #每次子树都会分别【递归去判断】左右子树的的最大情况 ，并最后加上1
                '''
                【思路】
                如果树的根为空，我们直接返回0
                如果树不为空，我们去判断它的左右子树，如果左子树的最大深度（包含左子树的左右子树情况+ 左子树的该节点）
                同理：如果右子树不为空，我们按照上面的方式去判断，
                
                最终的结果：
                在left 和 right中取一个最大值，在此的基础上加上1
                '''
        
        【非递归】
        我们可以使用层次遍历；把树的节点全部存储到数组中，并且遍历数组的维度；而数组的维度==树得到深度
         
         
        ##################################################################################################### 
        111.二叉树的最小深度    
        #####################################################################################################
        【思路】
        层次遍历：
        在每次出栈的时候，开始判断【节点】是否同时没有左右子树；如果没有则把当前这个值存入列表，并且把这个列表存入到res中 return len(res)
        否则；继续让左右子树的值入栈
        
                class Solution:
                    def minDepth(self, root: Optional[TreeNode]) -> int:

                        '''
                        迭代
                        '''
                        if not root:return 0
                        res = []
                        stack = [root]
                        while len(stack)!=0:
                            temp = []
                            for i in range(len(stack)):
                                b = stack.pop(0)
                                if not (b.left or b.right):
                                    temp.append(b.val)
                                    res.append(temp)
                                    return len(res)
                                if b.left:
                                    stack.append(b.left)
                                if b.right:
                                    stack.append(b.right)
                            res.append(temp)
                        return len(res)

        
        
        
        
        
        
        
        
        
        
        #####################################################################################################
        找树左下角的值
        #####################################################################################################
        1、层次遍历 + return res[len(res)-1][0]
