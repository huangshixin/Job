![图片](https://user-images.githubusercontent.com/38878365/185018394-0d801824-4cf3-48d0-a461-4492a7a8149f.png)


    解决方案：
    
    标签：动态规划
    
    首先初始化长度为n+1的数组dp，每个位置都为0
    
    如果n为0，则结果为0
    
    对数组进行遍历，下标为i，每次都将当前数字先更新为最大的结果，即dp[i]=i,比如i=4，最坏结果为4 =1+1+1+1
    
    转移方程： 
        
        dp[i] =min(dp[i],dp[i-j*j]+1),i表示当前的数字，j*j表示平方数
    
    时间复杂度：O(n∗sqrt(n))O(n*sqrt(n))O(n∗sqrt(n))，sqrt 为平方根
    
    class Solution {
        public int numSquares(int n) {
            int[] dp = new int[n + 1]; // 默认初始化值都为0
            for (int i = 1; i <= n; i++) {
                dp[i] = i; // 最坏的情况就是每次+1
                for (int j = 1; i - j * j >= 0; j++) { 
                    dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程
                }
            }
            return dp[n];
        }
    }


    
    
