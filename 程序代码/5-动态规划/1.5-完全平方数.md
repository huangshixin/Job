![图片](https://user-images.githubusercontent.com/38878365/185018394-0d801824-4cf3-48d0-a461-4492a7a8149f.png)


![图片](https://user-images.githubusercontent.com/38878365/186364500-434290d8-25db-41ef-ab1a-0454983f7d8e.png)

        
        假定，给定一个初始的正整数n=12，那么分析 平方数的可能性 从 【1，4，9，16】
        
        n     number
        1       1
        2       1+1
        3       1+1+1
        4       4=2^2
        5       有两种可能 1、1+dp[4]  2、4+dp[1]  它们分别代表着上述两个平方数 1 和 4的可能性，至于不可能是9 由于4《9
        6
        .
        .
        .
        12      分析12； 1、1+dp[11]  2、4+dp[8]  3、9+dp[3]  因此，动态规划去计算，上述中最小的那个值 就可以得出 当n=12时候，的最少个数；
        
        【#############################################################################################】
        【那么如何实现 1，4，9呢  ；可以设置一个值j【j从1开始递增，j《=i-j*j】； j*j就表示平方数的可能性】
        【#############################################################################################】

        
        
        
        class Solution:
            def numSquares(self, n: int) -> int:
                # 设置一个数组，用来存储小于 n 的那些完全平方数
                square = []

                # 通过一个下标来计算
                idx = 1

                # 直到 idx * idx 超过了 n 为止
                while idx * idx <= n : 
                    # square 存储小于 n 的那些完全平方数
                    square.append(idx * idx)

                    # idx 累加
                    idx+= 1


                # dp[0] 表示数字 0  需要完全平方数的最少数量
                # dp[1] 表示数字 0  需要完全平方数的最少数量
                # dp[i] 表示数字 i  需要完全平方数的最少数量
                # 先让 dp 初始化为 -1，代表 dp[i] 还没有计算
                dp = [-1 for _ in range( n + 1 )]

                # dp[0] 表示数字 0  需要完全平方数的最少数量
                dp[0] = 0

                # 开始填充 dp[]
                for i in range( 1 , n + 1 ) : 

                    # 在每次填充的过程中，都去遍历 square 数组
                    for j in range( 0 ,len(square) ) :  
                        # 如果发现此时 square 的元素值大于了 i
                        # 那么 square 后面的那些元素没有必要参与进来计算 i 了
                        # 直接退出当前的 j 的循环判断，让 i++
                        if square[j] > i: 
                            break


                        # 否则，如果 dp[i] 还没有找到数字 i 需要完全平方数的最少数量
                        # 或者此时计算的新值更小，那么更新 dp[i]
                        if dp[i] == -1 or dp[i] > dp[i-square[j]] + 1 : 

                            # 更新 dp[i]
                            # dp[i] 表示数字 i  需要完全平方数的最少数量
                            # 这个时候 dp[i] 为获取数字为 square.get(j) 的那 1 个完全平方数
                            # 加上获取数字为 i-square.get(j) 最少需要 dp[i-square.get(j)] 个数
                            dp[i] = dp[i-square[j]] + 1


                # dp[n] 表示数字 n 需要完全平方数的最少数量
                # 返回这个结果就行
                return dp[n]



    
    
