            给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

            示例:
            输入: n = 4, k = 2
            输出:
            [
            [2,4],
            [3,4],
            [2,3],
            [1,2],
            [1,3],
            [1,4],
            ]
            
            @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            
            #如果你需要的是
            【组合】  C（2，3） =3
            那么，【1，2】 【2，1】是同一个东西；
            因此：假定原始的集合为【1，2，3，4】
             1 --------------------------    【1，2，3，4】

             2 ---------【取1】         【取2】            【取3】          【取4】

             3---【剩下2，3，4】       【剩下 3，4】        【剩下4】         【null】
            
            【每次取一个元素后，集合中的元素就要丢掉一个】-------因为是组合
            
            @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            #如果需要的是排列 A（2，3） =6
            【1，2】 和 【2，1】是不同的两个子集
            【那么每次取一个元素后，集合不用丢弃当前取的这个元素】
            
            
            
            
            @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            
            【每次的范围在收缩】
            
            每次从集合中选取元素，【可选择的范围随着选择的进行而收缩】，调整可选择的范围。

            图中可以发现n相当于树的宽度，k相当于树的深度。
            
            那么如何在这个树上遍历，然后收集到我们要的结果集呢？

            图中每次搜索到了叶子节点，我们就找到了一个结果。

            相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。


            
            
            
            
            
            
           def combine(n:int,k:int):

                '''
                题目要求： 1-n个数中，有多少种子集，前提是子集的长度为k

                根据初始的模板，我们将设定两个数组；
                一个数组res用于存放 k种可能
                一个数组result用于存放 当前层的结果
                :param n:
                :param k:
                :param startindex:
                :return:
                '''
                res = []#存放最终的k个节点 eg【1，2，3】 k=3
                path = []
                def backtracking(n,k,startindex):

                    if len(path)==k:
                        #不需要返回任何东西,     【path存放的是该层的组合的个数】
                        res.append(path[:])
                        return
                    for i in range(startindex,n): #假设n=4,那么

                        path.append(i)#因为有多次循环，因此每次添加的时候
                        backtracking(n,k,i+1)
                        path.pop()
                backtracking(n,k,1)
                return res


