        
        回溯法，一般可以解决如下几种问题：

          组合问题：N个数里面按一定规则找出k个数的集合
          切割问题：一个字符串按一定规则有几种切割方式
          子集问题：一个N个数的集合里有多少符合条件的子集
          排列问题：N个数按一定规则全排列，有几种排列方式
          棋盘问题：N皇后，解数独等等
        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         比如一个集合
         排列：集合中抽出来【有序】的元素
         
         组合：集合中抽出来【无序】的元素
         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         回溯法解决的问题都可以抽象为【树形结构】，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

         因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度
         
         递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。
         
树结构的题目：可以思考能不能使用【回溯法】 #        
                        
         回溯法模板：
         
         1、回溯函数模板返回值以及参数
                void 一般是无返回的；
                
                所以一般是先写逻辑，然后需要什么参数，就填什么参数；
         
         2、回溯函数终止条件
                【@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@】
                【由于是树结构，而搜索的时候如果搜索到叶子节点，则结束搜索；】
                【@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@】
                什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
         
         3、回溯法实现的过程：
         
                 在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
                【@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@】
                【回溯法从开始节点出发时候，【集合】的大小构成了树的宽度，
                  而【递归】的深度构成了，树的深度                         】
                  
                  你可以理解为： 
                  宽度：
                        如果一个回溯算法（看成是多叉树），从某一个节点出发时候 ，该节点的能够到达的节点树，可以看成是一个宽度，而与这个节点在同一层的节点能够到达的节点数
                        可以看成是这一层的宽度
                  深度：递归到叶子节点的最大路径，看成是深度

          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      
                
                代码模板：
                
                void backtracking(参数) {
                    if (终止条件) {  #存放某个终止条件，一般是到叶子节点
                        存放结果;
                        return;
                    }

                    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {  #选择本层集合中的元素，因为本层的集合元素表示的是 【树在这一层的宽度】
                        处理节点;
                        backtracking(路径，选择列表); // 递归
                        回溯，撤销处理结果
                    }
                }

