问题1 ： 一个数组中，只有一个数出现奇数次，其余的次数均出现偶数次，问如何找到这个奇数次？

        【思路1】
        可以使用集合【它不允许出现的次数是重复的】，遍历整个数组，
        每次拿到一个数，都拿去和集合中的元素比较，
        如果【存在】，则让集合中的元素出来；
        【不存在】，就添加到集合中；
        经过遍历后，这个集合中只存在一个元素；就是出现【奇数次的】
        
        【位运算】
        1、使用“异或”操作，【相同为0，不同为1】  0异或1为1，故相同为0 不同为1
        【偶数次的数异或之后，都为0===无关顺序，等同于偶数次的数先异或，然后再异或奇数次的数】
        
        int eor = 0
        使用for循环对每一个数都异或一遍，最后返回eor即可
        def isA(num:list):
            eor = 0
            for i in num:
                eor = eor^i
            return eor
        
        【异或运算】
        为什么异或运算满足交换律呢？
       
       这个最终的结果，和某一个位置上1的个数有关
       
![图片](https://user-images.githubusercontent.com/38878365/195602024-370a3a77-291a-44d2-a868-bc1d5164f7a8.png)
        
        
        
问题2; 一个数组中，有两种数出现了奇数次，其余的均出现偶数次，问如何找到这两个奇数次？        
      
      【要求：时间复杂度o（n),空间复杂度O（1）】
        可以使用集合【它不允许出现的次数是重复的】，遍历整个数组，
        每次拿到一个数，都拿去和集合中的元素比较，
        如果【存在】，则让集合中的元素出来；
        【不存在】，就添加到集合中；
        经过遍历后，这个集合中只存在一个元素；就是出现【奇数次的】
        
        num = [2,2,3,3,4,4,5,5,7,7,8,8,1,1,9,6]
        def isNumber(num:list):
            '''
            num中除了两个元素，都出现过2次【使用集合判断咯】
            :param num:
            :return:
            '''
            a =set()
            for i in num:
                if i in a:
                    a.remove(i)
                else:
                    a.add(i)
            return list(a)
        
        【思路2】
        假设 这两个数是a 和 b，那么从头到尾对每一个数进行异或；偶数次的都被异或后---消除为0了而a和b不相同，故a^b不为0 ；
        
        【第一个信息】 得到a^b ,且 a^b不为0，因此某一位上是不等于0的
        
        【假定某一位不为0】，说明这一位上的数是不相同的，对于a和b；

        1、a^b不等于0，说明有一个位置上不等于0，利用这个关键，说明a，b在这个位置上是不相同的；我们可以设定一个新的变量，专门去异或【这个位置上为1】的数，这样，就相当于得到了a 或者b；
        
        a，b必定被分为两侧；
        
        2、那如何得到另一个数呢？
        eor = a^b
        
        设定新的变量 eor_new =a  or eor_new=b
        把eor ^eor_new 就可以得到另一个；
        
        
        
        
       class Solution:
            def singleNumbers(self, nums: List[int]) -> List[int]:
                '''哈希集合'''
                eor = 0
                for i in nums:
                    eor^=i

                #现在去查找这个数哪个位置为1；
                rightOne = eor& (~eor+1) #取出最右侧的1【技巧】
                onlyOne = 0

                #现在去原来的数组中去寻找，在该位置为1的数，然后与0异或
                for i in nums:
                    if (i&rightOne)==rightOne:
                        onlyOne^=i#这一部分相当于只拿了一侧的数据，【位运算，比算术运算快】
                return [onlyOne,eor^onlyOne]  # 之后拿之前的异或这个onlyOne
        
        
        
        
